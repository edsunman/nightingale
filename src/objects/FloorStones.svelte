<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@1.0.0-next.12 floorStones.glb -T
-->

<script>
    import { Group } from 'three'
    import { T, forwardEventHandlers } from '@threlte/core'
    import { useGltf, InstancedMeshes } from '@threlte/extras'
    import seedrandom from 'seedrandom'
    import { onMount } from 'svelte'

    export const ref = new Group()

    const gltf = useGltf('/floorStones-transformed.glb', { useDraco: true })

    const component = forwardEventHandlers()

    let sRandom = seedrandom('seed97')

    const rotationValues = [0, 1.5708, 3.14159]

    const items = Array.from({ length: 15 }, () => ({
        x: sRandom() * 18 - 9,
        z: sRandom() * 7 - 3,
        scale: 0.1,
        rotation: {
            x: 0,
            y: Math.floor(sRandom() * 3),
            z: 0
        }
    }))

    onMount(() => {
        items.forEach((i) => {
          //  console.log(i.rotation.y)
        })
    })
</script>

{#await gltf}
    <slot name="fallback" />
{:then gltf}
    <InstancedMeshes meshes={gltf.nodes} let:components={{ Mesh }} name={'floor stones'} castShadow receiveShadow>
        <T.MeshToonMaterial color="#555555" />
        {#each items as item}
            <Mesh
                position.y={0}
                position.z={item.z}
                position.x={item.x}
                scale={[0.12, 0.02, 0.22]}
                rotation.y={rotationValues[item.rotation.y]+0.22}
                rotation.x={0}
                rotation.z={0}
            />
        {/each}
    </InstancedMeshes>
{:catch error}
    <slot name="error" {error} />
{/await}

<slot {ref} />

<!--<InstancedMeshes meshes={gltf.nodes} let:components={{ Rock }} castShadow receiveShadow>
        <T.MeshToonMaterial color="#ac6130" />
        {#each items as item}
            <Rock
                position.y={0}
                position.z={item.z}
                position.x={item.x}
                scale={item.scale}
                rotation.y={(item.rotation.y * Math.PI) / 180}
                rotation.x={(item.rotation.x * Math.PI) / 180}
                rotation.z={(item.rotation.z * Math.PI) / 180}
            />
        {/each}
    </InstancedMeshes> -->
